No vasto mundo do desenvolvimento web, a autentica√ß√£o √© a guardi√£ de todos os reinos digitais. Neste tutorial veremos como proteger, autenticar e autorizar os usu√°rios de uma aplica√ß√£o Spring-Boot de forma nativa e seguindo as boas pr√°ticas da estrutura.

Usaremos as seguintes tecnologias:
- Java 17
- Spring-boot 3.1.5
- JWT
- Hibernate/JPA
- PostgreSQL
- lombok

>[C√≥digo fonte do projeto usado neste tutorial](https://github.com/m1guelsb/spring-auth). 


<TopicTitle title={"Primeiros passos"}/>
Para proteger nosso aplicativo, precisaremos de duas depend√™ncias em nosso `pom.xml`: a primeira √© o pacote de seguran√ßa nativo do Spring e a outra nos ajudar√° a criar e validar nossos tokens jwt.

<CodeHeader title="pom.xml" />
```xml
<dependency>
   <groupId>org.springframework.boot</groupId>
   <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<dependency>
   <groupId>com.auth0</groupId>
   <artifactId>java-jwt</artifactId>
   <version>4.4.0</version>
</dependency>
```


<TopicTitle title={"Entidade e reposit√≥rio do usu√°rio"} />
Primeiro precisaremos de um enum para representar as fun√ß√µes do usu√°rio, isso nos ajudar√° a definir as permiss√µes de cada usu√°rio em nossa aplica√ß√£o.

<CodeHeader title="/enums/UserRole.java" />
```java
public enum UserRole {
  ADMIN("admin"),
  USER("user");

  private String role;

  UserRole(String role) {
    this.role = role;
  }

  public String getValue() {
    return role;
  }
}
```
No enum temos dois pap√©is representativos: `ADMIN` e `USER`, o `ADMIN` ter√° acesso a todos os endpoints de nossa aplica√ß√£o, enquanto `USER` ter√° acesso apenas a endpoints espec√≠ficos.

A entidade do usu√°rio ser√° o n√∫cleo de nosso sistema de autentica√ß√£o, ela conter√° as credenciais do usu√°rio e as fun√ß√µes que o usu√°rio possui. Implementaremos a interface `UserDetails` para representar nossa entidade de usu√°rio, essa interface √© fornecida pelo pacote de seguran√ßa do spring e √© a maneira recomendada de representar a entidade do usu√°rio em uma aplica√ß√£o spring-boot.


<CodeHeader title="/entities/UserEntity.java" />
```java
@Table()
@Entity(name = "users")
@Getter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(of = "id")
public class User implements UserDetails {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  private String login;

  private String password;

  @Enumerated(EnumType.STRING)
  private UserRole role;

  public User(String login, String password, UserRole role) {
    this.login = login;
    this.password = password;
    this.role = role;
  }

  @Override
  public Collection<? extends GrantedAuthority> getAuthorities() {
    if (this.role == UserRole.ADMIN) {
      return List.of(new SimpleGrantedAuthority("ROLE_ADMIN"), new SimpleGrantedAuthority("ROLE_USER"));
    }
    return List.of(new SimpleGrantedAuthority("ROLE_USER"));
  }

  @Override
  public String getUsername() {
    return login;
  }

  @Override
  public boolean isAccountNonExpired() {
    return true;
  }

  @Override
  public boolean isAccountNonLocked() {
    return true;
  }

  @Override
  public boolean isCredentialsNonExpired() {
    return true;
  }

  @Override
  public boolean isEnabled() {
    return true;
  }
}
```

`UserDetails` tem uma s√©rie de m√©todos que podemos substituir para personalizar o processo de autentica√ß√£o, voc√™ tamb√©m pode implementar essas propriedades no banco de dados, mas por enquanto usaremos apenas as necess√°rias para fazer nosso sistema de autentica√ß√£o funcionar: `id`, `username`, `password` e `role`.

Para o reposit√≥rio do usu√°rio, temos o seguinte c√≥digo:
<CodeHeader title="/repositories/UserRepository.java" />
```java
public interface UserRepository extends JpaRepository<User, Long> {
  UserDetails findByLogin(String login);
}
```

Estendendo o `JpaRepository` teremos acesso a uma s√©rie de m√©todos para manipular nossos usu√°rios no banco de dados. Al√©m disso, o m√©todo `findByLogin` ser√° usado pelo spring security para encontrar o usu√°rio no banco de dados e validar as credenciais.

<TopicTitle title={"Token provider"} />
N√≥s precisamos definir uma chave para assinar nossos tokens. Usaremos a anota√ß√£o `@Value` para recuperar a chave secreta do `application.yml`. E no `application.yml` definiremos a chave secreta como uma vari√°vel de ambiente, isso nos ajudar√° a manter a chave secreta segura e fora do c√≥digo-fonte.

<CodeHeader title=".env" />
```env
JWT_SECRET="yoursecret"
```
In our `application.yml`:
<CodeHeader title="/resources/application.yml" />
```yml
security:
  jwt:
    token:
      secret-key: ${JWT_SECRET}
```

Para nossa aplica√ß√£o ler as vari√°veis de ambiente, precisamos declarar a anota√ß√£o `PropertySource` em nossa classe principal indicando onde est√° localizado o arquivo `.env`. No nosso caso, est√° localizado na raiz do projeto, ent√£o usaremos a vari√°vel `user.dir` para obter o caminho da raiz do projeto. A classe principal ficar√° assim:

<CodeHeader title="SpringAuthApplication.java" />
```java
@SpringBootApplication
@PropertySource("file:${user.dir}/.env")
public class SpringAuthApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringAuthApplication.class, args);
	}
}
```

Finalmente podemos definir a classe que ser√° respons√°vel por gerar e validar nossos tokens:

<CodeHeader title="/config/auth/TokenProvider.java" />
```java
@Service
public class TokenProvider {
  @Value("${security.jwt.token.secret-key}")
  private String JWT_SECRET;

  public String generateAccessToken(User user) {
    try {
      Algorithm algorithm = Algorithm.HMAC256(JWT_SECRET);
      return JWT.create()
          .withSubject(user.getUsername())
          .withClaim("username", user.getUsername())
          .withExpiresAt(genAccessExpirationDate())
          .sign(algorithm);
    } catch (JWTCreationException exception) {
      throw new JWTCreationException("Error while generating token", exception);
    }
  }

  public String validateToken(String token) {
    try {
      Algorithm algorithm = Algorithm.HMAC256(JWT_SECRET);
      return JWT.require(algorithm)
          .build()
          .verify(token)
          .getSubject();
    } catch (JWTVerificationException exception) {
      throw new JWTVerificationException("Error while validating token", exception);
    }
  }

  private Instant genAccessExpirationDate() {
    return LocalDateTime.now().plusHours(2).toInstant(ZoneOffset.of("-03:00"));
  }
}
```

Em `generateAccessToken` definimos o algoritmo, o `subject` e a data de expira√ß√£o dos tokens. No m√©todo `validateToken` checamos se o token √© v√°lido.

<TopicTitle title={"Security filter"} />
Then we need to define a filter to intercept the requests and validate the token. We'll be extending the `OncePerRequestFilter` spring security class to intercept the requests and validate the token.
Ent√£o precisamos definir um filtro para interceptar as solicita√ß√µes e validar o token. Estenderemos a classe `OncePerRequestFilter` do `spring security` para interceptar as solicita√ß√µes e validar o token.

<CodeHeader title="/config/auth/SecurityFilter.java" />
```java
@Component
public class SecurityFilter extends OncePerRequestFilter {
  @Autowired
  TokenProvider tokenService;
  @Autowired
  UserRepository userRepository;

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
      throws ServletException, IOException {
    var token = this.recoverToken(request);
    if (token != null) {
      var login = tokenService.validateToken(token);
      var user = userRepository.findByLogin(login);
      var authentication = new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
      SecurityContextHolder.getContext().setAuthentication(authentication);
    }
    filterChain.doFilter(request, response);
  }

  private String recoverToken(HttpServletRequest request) {
    var authHeader = request.getHeader("Authorization");
    if (authHeader == null)
      return null;
    return authHeader.replace("Bearer ", "");
  }
}
```
Em `doFilterInternal` recuperamos o token da requisi√ß√£o, removemos o "Bearer" da string usando o m√©todo auxiliar `recoverToken`, validamos o token e definimos a autentica√ß√£o no `SecurityContextHolder`. O `SecurityContextHolder` √© uma classe do spring security que guarda a autentica√ß√£o da solicita√ß√£o atual, para que possamos acessar as informa√ß√µes do usu√°rio nos controladores.

<TopicTitle title={"Auth config"} />
Aqui precisamos definir mais alguns m√©todos necess√°rios para fazer nosso sistema de autentica√ß√£o funcionar. Primeiro definimos no topo da classe as anota√ß√µes `Configuration` e `@EnableWebSecurity` para habilitar a seguran√ßa web em nossa aplica√ß√£o. Em seguida, definimos o bean `SecurityFilterChain` para definir os endpoints que ser√£o protegidos por nosso sistema de autentica√ß√£o.

<CodeHeader title="/config/AuthConfig.java" />
```java
@Configuration
@EnableWebSecurity
public class AuthConfig {
  @Autowired
  SecurityFilter securityFilter;

  @Bean
  SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
    return httpSecurity
        .csrf(csrf -> csrf.disable())
        .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(authorize -> authorize
            .requestMatchers(HttpMethod.POST, "/api/v1/auth/*").permitAll()
            .requestMatchers(HttpMethod.POST, "/api/v1/books").hasRole("ADMIN")
            .anyRequest().authenticated())
        .addFilterBefore(securityFilter, UsernamePasswordAuthenticationFilter.class)
        .build();
  }

  @Bean
  AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration)
      throws Exception {
    return authenticationConfiguration.getAuthenticationManager();
  }

  @Bean
  PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
  }
}
```

No m√©todo `authorizeHttpRequests` definimos os endpoints que ser√£o protegidos e os tipos de usu√°rios que ter√£o acesso a cada endpoint. Em nosso caso, os endpoints `/api/v1/auth/*` ser√£o p√∫blicos, o endpoint `/api/v1/books` ser√° protegido e apenas os usu√°rios com a fun√ß√£o `ADMIN` ter√£o acesso a ele. Os outros endpoints ser√£o protegidos e apenas os usu√°rios autenticados ter√£o acesso a eles.

No m√©todo `addFilterBefore` definimos o filtro que criamos anteriormente. E finalmente definimos os beans `AuthenticationManager` e `PasswordEncoder` que s√£o necess√°rios para fazer o sistema de autentica√ß√£o funcionar.


<TopicTitle title={"Auth DTOs"} />
Precisaremos de dois DTOs para receber as credenciais do usu√°rio e outro DTO para retornar o token quando o usu√°rio fizer login.

<CodeHeader title="/dtos/SignUpDto.java" />
```java
public record SignUpDto(
    String login,
    String password,
    UserRole role) {
}
``` 
<CodeHeader title="/dtos/SignInDto.java" />
```java
public record SignInDto(
    String login,
    String password) {
}
```
<CodeHeader title="/dtos/JwtDto.java" />
```java
public record JwtDto(
    String accessToken) {
}
``` 

<TopicTitle title={"Auth service"} />
Aqui definimos o service implementando `UserDetailsService` que ser√° respons√°vel por criar os usu√°rios e salv√°-los no banco de dados ou carregar as informa√ß√µes do usu√°rio pelo por seu nome.

<CodeHeader title="/services/AuthService.java" />
```java
@Service
public class AuthService implements UserDetailsService {

  @Autowired
  UserRepository repository;

  @Override
  public UserDetails loadUserByUsername(String username) {
    var user = repository.findByLogin(username);
    return user;
  }

  public UserDetails signUp(SignUpDto data) throws InvalidJwtException {
    if (repository.findByLogin(data.login()) != null) {
      throw new InvalidJwtException("Username already exists");
    }
    String encryptedPassword = new BCryptPasswordEncoder().encode(data.password());
    User newUser = new User(data.login(), encryptedPassword, data.role());
    return repository.save(newUser);
  }
}
```
Em `signUp` verificamos se o nome de usu√°rio j√° est√° registrado, em seguida, criptografamos a senha usando o `BCryptPasswordEncoder` e salvamos as informa√ß√µes do usu√°rio no reposit√≥rio.


<TopicTitle title={"Auth controller"} />
E finalmente definimos o controller. Ele ser√° respons√°vel por receber a solicita√ß√£o, autenticar os usu√°rios e gerar os tokens.

<CodeHeader title="/controllers/AuthController.java" />
```java
@RestController
@RequestMapping("/api/v1/auth")
public class AuthController {
  @Autowired
  private AuthenticationManager authenticationManager;
  @Autowired
  private AuthService service;
  @Autowired
  private TokenProvider tokenService;

  @PostMapping("/signup")
  public ResponseEntity<?> signUp(@RequestBody @Valid SignUpDto data) {
    service.signUp(data);
    return ResponseEntity.status(HttpStatus.CREATED).build();
  }

  @PostMapping("/signin")
  public ResponseEntity<JwtDto> signIn(@RequestBody @Valid SignInDto data) {
    var usernamePassword = new UsernamePasswordAuthenticationToken(data.login(), data.password());
    var authUser = authenticationManager.authenticate(usernamePassword);
    var accessToken = tokenService.generateAccessToken((User) authUser.getPrincipal());
    return ResponseEntity.ok(new JwtDto(accessToken));
  }
}
```

No m√©todo `signUp` recebemos os dados do usu√°rio, criamos um novo usu√°rio e o salvamos no banco de dados. No m√©todo `signIn` recebemos as credenciais do usu√°rio, autenticamos usando o `AuthenticationManager` e geramos o token.

<TopicTitle title={"Testando a autentica√ß√£o"} />
Para criar um novo usu√°rio, enviamos uma requisi√ß√£o `POST` para o endpoint `/api/v1/auth/signup` com um corpo contendo o login, senha e uma das fun√ß√µes dispon√≠veis (USER ou ADMIN):

```json
{
  "login": "myusername",
  "password": "123456",
  "role": "USER"
}
```
Para conseguir um token de autentica√ß√£o, enviamos outra requisi√ß√£o `POST` com as credenciais do usu√°rio que criamos anteriormente para o endpoint `/api/v1/auth/signin`.

Para testar o sistema de autentica√ß√£o criaremos um simples controller de livros com dois endpoints, um para criar um novo livro e outro para listar todos os livros.

```java
@RestController
@RequestMapping("/api/v1/books")
public class BookController {

  @GetMapping
  public ResponseEntity<List<String>> findAll() {
    return ResponseEntity.ok(List.of("Book1", "Book2", "Book3"));
  }

  @PostMapping
  public ResponseEntity<String> create(@RequestBody String data) {
    return ResponseEntity.ok(data);
  }
} 
```
No endpoint `/api/v1/books` o m√©todo `GET` estar√° dispon√≠vel para os usu√°rios com a fun√ß√£o `USER`, e o m√©todo `POST` ser√° protegido e apenas os usu√°rios com a fun√ß√£o `ADMIN` poder√£o criar um livro.

---

Eita! Muito c√≥digo n√©? üòÖ\
Espero que voc√™ tenha gostado e aprendido algo novo! Se voc√™ tiver alguma d√∫vida ou sugest√£o, sinta-se √† vontade para me enviar uma mensagem no [Twitter/X](https://x.com/m1guelsb).

Obrigado pela leitura!